---
title: "An Introduction to Data Types"
format:
  html: default
  ipynb: default
---

Intro paragraph

# Slides

Use the left ⬅️ and right ➡️ arrow keys to navigate through the slides below. To view in a separate tab/window, [follow this link](slides.html){target="_blank"}.

<iframe src="slides.html" height="500" width="100%"></iframe>

# Assigning types to variables

## Automatically

Python automatically assigns a type to a variable based on the value we put into it when we use the `=` assignment operator.

```{python}
our_integer = 1
our_float = 2.2
our_integer_turned_into_a_float = float(our_integer)
our_string="Hello SCW!"
```

## Manually

If we need to, we can use a *constructor function* named after the data type, like `int()` or `str()` to force a variable to be the specific type we need it to be.

```{python}
a = str("123") # a will contain the string 123 rather than the numeric value
b = float(2) # b will contain the decimal value 2.0
c = int(1.9) # just throws away the .9; not rounded!
```

## Finding out what type a variable is

```{python}
print (type(a))
print (type(b))
print (type(c))
```

# Data types

## Booleans

Bools are often an intermediate - they are an output of evaluations like `1 == 2`. Booleans may sound very basic, but they are crucial in understanding control flow, which we'll be covering in a future session!

```{python}
z = True			# you'll rarely ever assign a boolean directly like this, but do note they are
					# case sensitive; z = true wouldn't have worked here.
print(type(z)) 		# output: <class 'bool'>
print (10>9)		# output: True
print (1 == 2)		# output: False
 
print(bool(123))	# output: True
print(bool("abc"))	# output: True
print(bool(None))	# output: False
print(bool(0))		# output: False
```


## Numeric types

Python supports different kinds of numbers, including integers (int), floating point numbers (float). You can do basic arithmetic (+, -, *, /), exponentiation (**), and use built-in functions like round(), abs(), and pow().
 
```{python}
a = 10  			# int
b = 3   			# int
c = 2.5 			# float
d = -2  			# int

print(a+b) 			# output: 13, an int
print(a+c) 			# output: 12.5, a float
print(a ** (1/2))   # taking the square root of an int returns a float
 
print(float(a)) 	# output: 10.0
print(int(2.88)) 	# output: 2; just throws away the decimal part
 
print(round(2.88)) 	# output: 3
print(round(2.88,1))# output: 2.9
```

## Strings

Strings are sequences of characters enclosed in quotes. They support indexing, slicing, and a wide range of methods like .lower(), .replace(), .split(), and .join().

```{python}
str_a = "Hello" 			 # string
str_b = "SCW!"  			 # string

str_ab = str_a + " " + str_b # python repurposes the "+" to mean string concatenation as well as addition
print(str_ab)                # output: Hello SCW!
 
print(str_ab.find("SCW"))	 # output:6 (the location in the string of the substring "SCW". Starts from 0!)
 
str_repeated = str_ab * 3 
print(str_repeated)          # output: Hello SCW!Hello SCW!Hello SCW!
 
print(len(str_a))  			 # output: 5
print(str_a[0])				 # output: H
print(str_a[0:3])			 # output: Hel (give me 3 characters starting at 0)
print(str_a[3:])			 # output: lo (give me everything starting at 3)
print(str_a[:5])			 # output: Hello (give me the first 5 characters)
```

## Lists

Lists are ordered, mutable (changeable) collections. They can hold any type of data and support operations like appending (`.append()`), removing (`.remove()`), and slicing (`our_list[1:4]`).

```{python}
fruits = ["banana", "lychee", "raspberry", "apple"]
print(fruits[0]) 		#output: banana (string)
print(fruits[0:2])		#output: ['banana','lychee'] (list!)
print(fruits[-1])		#output: apple (string)

fruits.append("orange")
print(fruits) 			#output: ['banana', 'lychee', 'raspberry', 'apple', 'orange']

print("orange" in fruits) #output: True
print("tomato" in fruits) #output: False

fruits.sort()
print(fruits)			#output: ['apple', 'banana', 'lychee', 'orange', 'raspberry']

mixed_list = ["blue", "green", False, 2, 2.55] #each item in a list can be a different data type!
for item in mixed_list:
	print(type(item)) 	#output:<class 'str'> <class 'str'> <class 'bool'> <class 'int'> <class 'float'>

str_number = "123"
print(type(str_number)) #output:<class 'str'>
str_number=int(str_number)
print(type(str_number)) #output:<class 'int'>

a = 321
print(type(a)) 			#output:<class 'int'>
a = float(a)
print(type(a)) 			#output:<class 'float'>

#b = int("kiwi")		#output: ValueError: invalid literal for int() with base 10: 'kiwi'
```

## Dicts

Dictionaries store key-value pairs and are optimized for lookups. Keys must be unique and are immutable, but values are mutable. You can add, update, or delete items using dict[key] = value, dict.get(key), or del dict[key].

```{python}
SCW_basic_info={
	"org_code"		: "0DF",
	"short_name"	: "SCW CSU",
	"long_name"		: "NHS South, Central and West Commissioning Support Unit",
	"year_opened"	: 2014,
	"active"		: True,
	"postcode"		: "SO50 5PB"
}

print(type(SCW_basic_info["active"]))		#output: <class 'bool'>
print(type(SCW_basic_info["year_opened"])) 	#output: <class 'int'>

print(SCW_basic_info["org_code"])			#output: "0DF"
print(len(SCW_basic_info))					#output: 6

SCW_basic_info["number_of_staff"] = 1000	#we can easily add a new key and value at the same time

print(len(SCW_basic_info))					#output: 7

SCW_basic_info["number_of_staff"] += 1 		#we hired a new member of staff
print(SCW_basic_info["number_of_staff"])	#output: 1001
```

# Exercises