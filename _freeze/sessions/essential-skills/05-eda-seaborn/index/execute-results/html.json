{
  "hash": "9440e2c2ff8e97ded19f9b325a419b1a",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Visually Exploring Data Using Seaborn\"\nformat:\n  html: default\n  ipynb: default\n---\n\nThis session will build on the previous session that introduced the Seaborn library, using it to visualise data and do some exploratory analysis.\n\nWe are using [Australian weather data](https://www.kaggle.com/datasets/jsphyg/weather-dataset-rattle-package), taken from [Kaggle](https://kaggle.com). This dataset is used to build machine learning models that predict whether it will rain tomorrow, using data about the weather every day from 2007 to 2017. To download the data, click <a href=\"data/weatherAUS.csv\" download>here</a>.\n\nThe objective from this session is to:\n\n- Understand how to describe data quantitatively and when different methods are appropriate\n- Visualise data as a means of describing it\n- Show how to visualising data is a shortcut for describing central tendency, spread, uncertainty etc.\n- Introduce ideas around describing and visualising relationships between variables\n\n::: {#setup .cell execution_count=1}\n``` {.python .cell-code}\n# import packages\nimport warnings\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nimport seaborn as sns\n\n# control some deprecation warnings in seaborn\nwarnings.filterwarnings(\n    \"ignore\",\n    category=FutureWarning,\n    module=\"seaborn\"\n)\n\n# import the dataset\ndf = pd.read_csv('data/weatherAUS.csv')\n```\n:::\n\n\nFirst, we will take a subset of the data, using Australia's five biggest cities. This gives us a more manageable dataset to work with.\n\n::: {#big-cities-subset .cell execution_count=2}\n``` {.python .cell-code}\n# subset of observations from five biggest cities\nbig_cities = (\n    df.loc[df['Location'].isin(['Adelaide', 'Brisbane', 'Melbourne', 'Perth', 'Sydney'])]\n    .copy()\n)\n```\n:::\n\n\n## Exploratory Data Analysis\n\nWhat does exploratory data analysis aim to achieve? What are you looking for when visualising data? **Patterns, shapes, signals!**\n\nWhen we describe a variable, or a sample of that variable, we are interested in understanding the characteristics of the observations. The starting point for doing this is describing the value that the data tends to take (central tendency), and how much it tends to deviate from its typical value (spread). Visualising the distribution of a variable can tell us these things (approximately), and can tell us about the shape of the data too.\n\nThe \"central tendency\" is the average or most common value that a variable takes. Mean, median, and mode are all descriptions of the central tendency.\n\n- Mean - Sum of values in a sample divided by the total number of observations.\n- Median - The midpoint value if the sample is ordered from highest to lowest.\n- Mode - The most common value in the sample[^Mode].\n\nThe mean is the most common approach, but the mean, median, and mode choice are context-dependent. Other approaches exist, too, such as the geometric mean[^Geometric].\n\n::: {#cell-mode-rainfall .cell execution_count=3}\n``` {.python .cell-code}\n# mode rainfall by location\nbig_cities.groupby('Location')['Rainfall'].agg(pd.Series.mode)\n```\n\n::: {#mode-rainfall .cell-output .cell-output-display execution_count=3}\n```\nLocation\nAdelaide     0.0\nBrisbane     0.0\nMelbourne    0.0\nPerth        0.0\nSydney       0.0\nName: Rainfall, dtype: float64\n```\n:::\n:::\n\n\n::: {#cell-mode-location .cell execution_count=4}\n``` {.python .cell-code}\n# mode location\nbig_cities['Location'].agg(pd.Series.mode)\n```\n\n::: {#mode-location .cell-output .cell-output-display execution_count=4}\n```\n0    Sydney\nName: Location, dtype: object\n```\n:::\n:::\n\n\n::: {#cell-location-value-counts .cell execution_count=5}\n``` {.python .cell-code}\n# mode location using value counts\nbig_cities['Location'].value_counts().iloc[0:1]\n```\n\n::: {#location-value-counts .cell-output .cell-output-display execution_count=5}\n```\nLocation\nSydney    3344\nName: count, dtype: int64\n```\n:::\n:::\n\n\n::: {#cell-mean-rainfall-location .cell execution_count=6}\n``` {.python .cell-code}\n# mean rainfall by location\nnp.round(big_cities.groupby('Location')['Rainfall'].mean(), decimals=2)\n```\n\n::: {#mean-rainfall-location .cell-output .cell-output-display execution_count=6}\n```\nLocation\nAdelaide     1.57\nBrisbane     3.14\nMelbourne    1.87\nPerth        1.91\nSydney       3.32\nName: Rainfall, dtype: float64\n```\n:::\n:::\n\n\n::: {#cell-median-rainfall-location .cell execution_count=7}\n``` {.python .cell-code}\n# median rainfall by location\nbig_cities.groupby('Location')['Rainfall'].median()\n```\n\n::: {#median-rainfall-location .cell-output .cell-output-display execution_count=7}\n```\nLocation\nAdelaide     0.0\nBrisbane     0.0\nMelbourne    0.0\nPerth        0.0\nSydney       0.0\nName: Rainfall, dtype: float64\n```\n:::\n:::\n\n\n::: {#cell-mean-max-temp-location .cell execution_count=8}\n``` {.python .cell-code}\n# geometric mean max temperature by location\nbig_cities.groupby('Location')['MaxTemp'].apply(lambda x: np.exp(np.log(x).mean()))\n```\n\n::: {#mean-max-temp-location .cell-output .cell-output-display execution_count=8}\n```\nLocation\nAdelaide     21.888697\nBrisbane     26.152034\nMelbourne    19.972352\nPerth        24.320203\nSydney       22.570993\nName: MaxTemp, dtype: float64\n```\n:::\n:::\n\n\nThe values across the different measures of central tendency are not always the same. In this case, the mean and median differs massively.\n\n**Questions**:\n\n- Why is that? Why would the median rainfall be zero for all five cities?\n- Does this matter? How would it change our understanding of the rainfall variable?\n\nDistributions can tell us more. We have simulated three different distributions that have slightly different shapes, to see how their mean and median values differ.\n\n::: {#cell-plot-skewed-distributions .cell execution_count=9}\n``` {.python .cell-code code-fold=\"true\" code-summary=\"Plot Code (Click to Expand)\"}\n# generate distributions\nnp.random.seed(123)\nnormal_dist = np.random.normal(10, 1, 1000)\nright_skewed_dist = np.concatenate([np.random.normal(8, 2, 600), np.random.normal(14, 4, 400)])\nleft_skewed_dist = np.concatenate([np.random.normal(14, 2, 600), np.random.normal(8, 4, 400)])\n\n# set figure size\nplt.rcParams['figure.figsize'] = (12, 6)\n\n# function for calculating summary statistics and plotting distributions\ndef plot_averages(ax, data, title):\n    mean = np.mean(data)\n    median = np.median(data)\n    \n    sns.histplot(data, color=\"#d9dcd6\", bins=30, ax=ax)\n    ax.axvline(mean, color=\"#0081a7\", linewidth=3, linestyle=\"--\", label=f\"Mean: {mean:.2f}\")\n    ax.axvline(median, color=\"#ef233c\", linewidth=3, linestyle=\"--\", label=f\"Median: {median:.2f}\")\n    ax.set_title(title)\n    ax.set_ylabel('')\n    ax.legend()\n\n# plot distributions\nfig, axes = plt.subplots(1, 3, sharey=True)\n\nplot_averages(axes[0], normal_dist, \"Normal Distribution\\n(Mean â‰ˆ Median)\")\nplot_averages(axes[1], right_skewed_dist, \"Right-Skewed Distribution\\n(Mean > Median)\")\nplot_averages(axes[2], left_skewed_dist, \"Left-Skewed Distribution\\n(Mean < Median)\")\n\nplt.suptitle(\"Comparison of Mean & Median Across Distributions\", fontsize=16)\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/plot-skewed-distributions-output-1.png){#plot-skewed-distributions}\n:::\n:::\n\n\nThe mean and median of the normal distribution are identical, while the two skewed distributions have slightly different means and medians.\n\n- The mean is larger than the median when the distribution is right-skewed, and the median is larger than the mean when it is left-skewed.\n    - When the distribution is skewed, the median value will be a better description of the central tendency, because the mean value is more sensitive to extreme values (and skewed distributions have longer tails of extreme values).\n\nThese differences point to another important factor to consider when summarising data - the spread or deviation of the sample.\n\n- How do we measure how a sample is spread around the central tendency?\n    - Standard deviation and variance quantify spread.\n    - Variance, the average squared difference between observations and the mean value, measures how spread out a sample is.\n    - Standard deviation is the square root of the variance. It's easier to interpret because it's in the same units as the sample.\n\n::: {#cell-plot-variance-distributions .cell execution_count=10}\n``` {.python .cell-code code-fold=\"true\" code-summary=\"Plot Code (Click to Expand)\"}\n# generate distributions\nnp.random.seed(123)\nmean = 10\nstd_devs = [1, 2, 3]\ndistributions = [np.random.normal(mean, std_dev, 1000) for std_dev in std_devs]\n\n# function for calculating summary statistics and plotting distributions\ndef plot_spread(ax, data, std_dev, title):\n    mean = np.mean(data)\n    std_dev = np.std(data)\n\n    sns.histplot(data, color=\"#d9dcd6\", bins=30, ax=ax)\n    ax.axvline(mean, color=\"#0081a7\", linewidth=3, linestyle=\"--\", label=f\"Mean: {mean:.2f}\")\n    ax.axvline(mean + std_dev, color=\"#ee9b00\", linewidth=3, linestyle=\"--\", label=f\"Mean + 1 SD: {mean + std_dev:.2f}\")\n    ax.axvline(mean - std_dev, color=\"#ee9b00\", linewidth=3, linestyle=\"--\", label=f\"Mean - 1 SD: {mean - std_dev:.2f}\")\n    ax.set_title(f\"{title}\")\n    ax.legend()\n\n# plot distributions\nfig, axes = plt.subplots(1, 3, sharey=True, sharex=True)\n\nfor i, std_dev in enumerate(std_devs):\n    plot_spread(axes[i], distributions[i], std_dev, f\"Standard Deviation = {std_dev}\")\n\nplt.suptitle(\"Effect of Standard Deviation on Distribution Shape\", fontsize=16)\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/plot-variance-distributions-output-1.png){#plot-variance-distributions}\n:::\n:::\n\n\nAs standard deviation increases, the spread of values around the mean increases.\n\nWe can compute various summary statistics that describe a sample (mean, median, standard deviation, kurtosis etc. etc.), or we can just visualise it!\n\nVisualising distributions is a good starting point for understanding a sample. It can quickly and easily tell you a lot about the data.\n\n[^Mode]:\n\nThe mode value is generally most useful when dealing with categorical variables.\n\n[^Geometric]:\n\nThe geometric mean multiplies all values in the sample and takes the $n$th root of that multiplied value. It can be useful when dealing with skewed data or data with very large ranges, and when dealing with rates, proportions etc. However it can't handle zeros or negative values.\n\n## Exploring Australian Weather\n\n### Visualising Single Variables\n\nWe can start by visualising the distribution of rainfall and sunshine in Australia's big cities, including dashed lines to show the mean and median values.\n\n::: {#cell-rainfall-distribution .cell execution_count=11}\n``` {.python .cell-code}\n# plot distribution of rainfall\nrainfall_mean = np.mean(big_cities['Rainfall'])\nrainfall_median = np.median(big_cities['Rainfall'].dropna())\n\nsns.histplot(data=big_cities, x='Rainfall', binwidth=10, color=\"#d9dcd6\")\nplt.axvline(rainfall_mean, color=\"#0081a7\", linestyle=\"--\", linewidth=2, label=f\"Mean: {rainfall_mean:.2f}\")\nplt.axvline(rainfall_median, color=\"#ef233c\", linestyle=\"--\", linewidth=2, label=f\"Median: {rainfall_median:.2f}\")\n\nplt.title(\"Distribution of Rainfall in Australia's Big Cities\")\n\nplt.legend()\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/rainfall-distribution-output-1.png){#rainfall-distribution}\n:::\n:::\n\n\n::: {#cell-sunshine-distribution .cell execution_count=12}\n``` {.python .cell-code}\n# plot distribution of sunshine\nsunshine_mean = np.mean(big_cities['Sunshine'])\nsunshine_median = np.median(big_cities['Sunshine'].dropna())\n\nsns.histplot(data=big_cities, x='Sunshine', binwidth=1, color=\"#d9dcd6\")\nplt.axvline(sunshine_mean, color=\"#0081a7\", linestyle=\"--\", linewidth=2, label=f\"Mean: {sunshine_mean:.2f}\")\nplt.axvline(sunshine_median, color=\"#ef233c\", linestyle=\"--\", linewidth=2, label=f\"Median: {sunshine_median:.2f}\")\n\nplt.title(\"Distribution of Sunshine in Australia's Big Cities\")\n\nplt.legend()\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/sunshine-distribution-output-1.png){#sunshine-distribution}\n:::\n:::\n\n\nRainfall is very skewed, because the vast majority of days have zero rainfall. The distribution of sunshine is a little more evenly spread.\n\nWhile these two plots require a little more code, we can get most of what we want with a lot less just using `sns.histplot()` on its own. For example, plotting the distribution of maximum temperature, without all the other bells and whistles, already tells us a lot.\n\n::: {#cell-max-temp-distribution .cell execution_count=13}\n``` {.python .cell-code}\nsns.histplot(data=big_cities, x='MaxTemp')\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/max-temp-distribution-output-1.png){#max-temp-distribution}\n:::\n:::\n\n\nWe can also look at the distribution of observations split by group, using `sns.countplot()`. Below, we see the number of observations per city in our subset.\n\n::: {#cell-location-distribution .cell execution_count=14}\n``` {.python .cell-code}\nsns.countplot(big_cities, x='Location', color=\"#d9dcd6\", edgecolor='black')\nplt.ylim(3000, 3500)\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/location-distribution-output-1.png){#location-distribution}\n:::\n:::\n\n\nSimilarly, we can look at the number of days with or without rain the next day.\n\n::: {#cell-rain-tomorrow-distribution .cell execution_count=15}\n``` {.python .cell-code}\nsns.countplot(big_cities, x='RainTomorrow', color=\"#d9dcd6\", edgecolor='black')\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/rain-tomorrow-distribution-output-1.png){#rain-tomorrow-distribution}\n:::\n:::\n\n\nHowever, it's worth noting there is a simpler approach to this, just using `pd.DataFrame.value_counts()`.\n\n::: {#cell-count-rain-tomorrow .cell execution_count=16}\n``` {.python .cell-code}\nbig_cities['RainTomorrow'].value_counts()\n```\n\n::: {#count-rain-tomorrow .cell-output .cell-output-display execution_count=16}\n```\nRainTomorrow\nNo     11673\nYes     3543\nName: count, dtype: int64\n```\n:::\n:::\n\n\n### Visualising Multiple Variables\n\nWe will often want to know how values of a given variable change based on the values of another. This may not indicate a relationship, but it helps us better understand our data. There are lots of ways we can do this.\n\nWe can use `sns.barplot()` to plot the average hours of sunshine by location.\n\n::: {#cell-sunshine-location-boxplot .cell execution_count=17}\n``` {.python .cell-code}\nsns.barplot(big_cities, x='Location', y='Sunshine', color=\"#d9dcd6\", edgecolor='black')\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/sunshine-location-boxplot-output-1.png){#sunshine-location-boxplot}\n:::\n:::\n\n\nOr we could use `sns.boxplot()`, visualising the distribution of maximum temperatures and humidity at 3pm by location.\n\n::: {#cell-max-temp-location-boxplot .cell execution_count=18}\n``` {.python .cell-code}\nsns.boxplot(big_cities, x='Location', y='MaxTemp', color=\"#d9dcd6\")\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/max-temp-location-boxplot-output-1.png){#max-temp-location-boxplot}\n:::\n:::\n\n\n::: {#cell-humidity-rain-tomorrow-boxplot .cell execution_count=19}\n``` {.python .cell-code}\nsns.boxplot(data=big_cities, x='RainTomorrow', y='Humidity3pm', color=\"#d9dcd6\")\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/humidity-rain-tomorrow-boxplot-output-1.png){#humidity-rain-tomorrow-boxplot}\n:::\n:::\n\n\nAnother way we can compare the distribution of values by groups is using `sns.kdeplot()`, which visualises a [kernel-density estimation](https://seaborn.pydata.org/tutorial/distributions.html#tutorial-kde).\n\n::: {#cell-humidity-rain-tomorrow-kde-plot .cell execution_count=20}\n``` {.python .cell-code}\nsns.kdeplot(data=big_cities, x='Humidity3pm', hue='RainTomorrow')\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/humidity-rain-tomorrow-kde-plot-output-1.png){#humidity-rain-tomorrow-kde-plot}\n:::\n:::\n\n\nWhile there are lots of different ways we can quickly and easily compare two variables, or compare the value of a variable by groups, the right approach will always be context-dependent. It will all depend on what questions you have about your data, and which variables you are interested in.\n\nIf you have lots of questions about multiple variables, one way of exploring quickly is `sns.pairplot()`.\n\n::: {#cell-pairplot .cell execution_count=21}\n``` {.python .cell-code}\nbiggest_cities = big_cities.loc[big_cities[\"Location\"].isin(['Sydney', 'Melbourne'])]\nsns.pairplot(\n    biggest_cities,\n    vars=['MinTemp', 'Sunshine', 'Rainfall'],\n    hue='Location'\n    )\n\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/pairplot-output-1.png){#pairplot}\n:::\n:::\n\n\nI tend to struggle to infer much from complex plots like this, so I prefer to create separate plots using `sns.scatterplot()`.\n\n::: {#cell-sunshine-scatterplot .cell execution_count=22}\n``` {.python .cell-code}\nsns.scatterplot(big_cities, x='Sunshine', y='MaxTemp', alpha=0.5)\n\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/sunshine-scatterplot-output-1.png){#sunshine-scatterplot}\n:::\n:::\n\n\nScatterplots can help you visualise how two continuous variables vary together. The above plot shows that sunshine hours are positively associated with maximum temperature, but there is significant noise.\n\nIf we compare this with a scatterplot visualising the association between two variables that should have a strong relationship, such as humidity at 9am and 3pm, we can see the difference.\n\n::: {#cell-humidity-scatterplot .cell execution_count=23}\n``` {.python .cell-code}\nsns.scatterplot(big_cities, x='Humidity9am', y='Humidity3pm', alpha=0.5)\n\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/humidity-scatterplot-output-1.png){#humidity-scatterplot}\n:::\n:::\n\n\nThere is still plenty of noise, but as humidity at 9am increases, it is clear that humidity at 3pm is likely to increase.\n\nAnother change we might make, to reduce the noise, is adding grouping structures to our scatterplot. Perhaps much of the noise in the sunshine scatterplot is because we are looking at data across many cities.\n\n::: {#cell-scatterplot .cell execution_count=24}\n``` {.python .cell-code}\nsns.scatterplot(biggest_cities, x='Sunshine', y='MaxTemp', hue='Location', alpha=0.5)\n\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/scatterplot-output-1.png){#scatterplot}\n:::\n:::\n\n\nWhen we compare just two cities, there still appears to be significant noise.\n\nSometimes you might need to do some more complex operations to transform the data before visualising it, in order to ask more specific questions. For example, you might want to compare how the total rainfall per day has varied over time in the data.\n\n::: {#cell-rainfall-over-time .cell execution_count=25}\n``` {.python .cell-code}\n(\n    big_cities\n    # convert date to datetime\n    .assign(Date=pd.to_datetime(big_cities['Date']))\n    # create year-month column\n    .assign(Year_Month=lambda x: x['Date'].dt.to_period('M'))\n    # group by year-month and calculate sum of rainfall\n    .groupby('Year_Month')['Rainfall'].sum()\n    # convert year-month index back to column in dataframe\n    .reset_index()\n    # create year-month timestamp for plotting\n    .assign(Year_Month=lambda x: x['Year_Month'].dt.to_timestamp()) \n    # pass df object to seaborn lineplot\n    .pipe(lambda df: sns.lineplot(data=df, x='Year_Month', y='Rainfall', linewidth=2))\n)\n\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/rainfall-over-time-output-1.png){#rainfall-over-time}\n:::\n:::\n\n\nThe above plot leverages an approach called [method chaining](https://tomaugspurger.net/posts/method-chaining/), where we call multiple methods one after the other in the same operation[^Chaining]. Method chaining syntax is sometimes a little easier to follow, and you don't have to create new objects for every operation, which can be a tidier way to work.\n\nWe can do the same to transform the data and visualise the mean average sunshine per month.\n\n::: {#cell-sunshine-over-time .cell execution_count=26}\n``` {.python .cell-code}\n(\n    big_cities\n    # convert date to datetime object\n    .assign(Date=pd.to_datetime(big_cities['Date']))\n    # set date column as index\n    .set_index('Date')\n    # resample by month-end for monthly aggregations\n    .resample('ME')\n    # calculate mean sunshine per month\n    .agg({'Sunshine': 'mean'})\n    # convert month index back to column in dataframe\n    .reset_index()\n    # pass df object to seaborn lineplot\n    .pipe(lambda df: sns.lineplot(data=df, x='Date', y='Sunshine', color=\"#1f77b4\", linewidth=2))\n)\n\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/sunshine-over-time-output-1.png){#sunshine-over-time}\n:::\n:::\n\n\nFinally, we could combine two plots to look at how the average rainfall and average sunshine both vary by month.\n\n::: {#cell-rainfall-sunshine-seasonality .cell execution_count=27}\n``` {.python .cell-code}\nfig, axes = plt.subplots(1, 2)\n\n(\n    big_cities\n    .assign(Date=pd.to_datetime(big_cities['Date']))\n    .assign(Month=lambda x: x['Date'].dt.month)\n    .groupby('Month')['Rainfall'].mean()\n    .reset_index()\n    .pipe(lambda df: sns.lineplot(data=df, x='Month', y='Rainfall', color=\"#1f77b4\", linewidth=2, ax=axes[0]))\n)\n\n(\n    big_cities\n    .assign(Date=pd.to_datetime(big_cities['Date']))\n    .assign(Month=lambda x: x['Date'].dt.month) \n    .groupby('Month')['Sunshine'].mean() \n    .reset_index()\n    .pipe(lambda df: sns.lineplot(data=df, x='Month', y='Sunshine', color=\"#ff7f0e\", linewidth=2, ax=axes[1]))\n)\n\nxticks = range(1, 13)\nxticklabels = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']\nfor ax in axes:\n    ax.set_xticks(xticks)  # Set ticks\n    ax.set_xticklabels(xticklabels, rotation=45)\n    ax.set_xlabel('')\n    ax.set_ylabel('')\naxes[0].set_title('Average Rainfall by Month', fontsize=16)\naxes[1].set_title('Average Sunshine by Month', fontsize=16)\n\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/rainfall-sunshine-seasonality-output-1.png){#rainfall-sunshine-seasonality}\n:::\n:::\n\n\n[^Chaining]:\n\nThis may not be something you feel comfortable with yet, but it is something you may come across, and could explore in the future.\n\n## Exercises\n\nSome of these questions are easily answered by scrolling up and finding the answer in the output of the above code, however, the goal is to find the answer using code. No one actually cares what the answer to any of these questions is, it's the process that matters!\n\n**Remember, if you don't know the answer, it's okay to Google it (or speak to others, including me, for help)!**\n\n::: {#reset-data .cell execution_count=28}\n``` {.python .cell-code code-fold=\"true\" code-summary=\"Import Data (to Reset)\"}\n# import the dataset\ndf = pd.read_csv('data/weatherAUS.csv')\n```\n:::\n\n\n1. What does the distribution of minimum daily temperatures look like in these cities? Are there any unusual patterns?\n\n::: {.callout-note title=\"Solution\" collapse=\"true\"}\n\n::: {#cell-min-temp .cell execution_count=29}\n``` {.python .cell-code}\nsns.histplot(big_cities[\"MinTemp\"].dropna(), kde=True)\nplt.title(\"Distribution of MinTemp\")\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/min-temp-output-1.png){#min-temp}\n:::\n:::\n\n\n:::\n\n2. Does the amount of sunshine vary depending on whether it rains the next day? Visualise this.\n\n::: {.callout-note title=\"Solution\" collapse=\"true\"}\n\n::: {#cell-sunshine-boxplot .cell execution_count=30}\n``` {.python .cell-code}\nsns.boxplot(data=big_cities, x=\"RainTomorrow\", y=\"Sunshine\")\nplt.title(\"Sunshine by Rain Tomorrow\")\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/sunshine-boxplot-output-1.png){#sunshine-boxplot}\n:::\n:::\n\n\n:::\n\n3. How closely related are atmospheric pressure readings in the morning compared to the afternoon?\n\n::: {.callout-note title=\"Solution\" collapse=\"true\"}\n\n::: {#cell-air-pressure .cell execution_count=31}\n``` {.python .cell-code}\nsns.scatterplot(data=big_cities, x=\"Pressure9am\", y=\"Pressure3pm\")\nplt.title(\"Pressure at 9am vs 3pm\")\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/air-pressure-output-1.png){#air-pressure}\n:::\n:::\n\n\n:::\n\n4. How does humidity in the afternoon vary across the five cities? What can you infer from this?\n\n::: {.callout-note title=\"Solution\" collapse=\"true\"}\n\n::: {#cell-humidity .cell execution_count=32}\n``` {.python .cell-code}\nsns.violinplot(data=big_cities, x=\"Location\", y=\"Humidity3pm\")\nplt.title(\"Humidity at 3pm by City\")\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/humidity-output-1.png){#humidity}\n:::\n:::\n\n\n:::\n\n5. Are days when rain is expected tomorrow more or less common in this dataset? Show the distribution.\n\n::: {.callout-note title=\"Solution\" collapse=\"true\"}\n\n::: {#cell-rain-tomorrow-counts .cell execution_count=33}\n``` {.python .cell-code}\nsns.countplot(data=big_cities, x=\"RainTomorrow\")\nplt.title(\"Rain Tomorrow Counts\")\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/rain-tomorrow-counts-output-1.png){#rain-tomorrow-counts}\n:::\n:::\n\n\n:::\n\n6. Is there any relationship between afternoon temperature and humidity? Does this relationship change depending on whether it rains the next day?\n\n::: {.callout-note title=\"Solution\" collapse=\"true\"}\n\n::: {#cell-temp-by-humidity .cell execution_count=34}\n``` {.python .cell-code}\nsns.scatterplot(data=big_cities, x=\"Temp3pm\", y=\"Humidity3pm\", hue=\"RainTomorrow\")\nplt.title(\"Temp vs Humidity at 3pm by Rain Tomorrow\")\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/temp-by-humidity-output-1.png){#temp-by-humidity}\n:::\n:::\n\n\n:::\n\n7. How strongly are the different continuous variables in this dataset correlated with each other? Create a correlation matrix.\n\n::: {.callout-note title=\"Solution\" collapse=\"true\"}\n\n::: {#cell-corr-matrix .cell execution_count=35}\n``` {.python .cell-code}\ncorr = big_cities.select_dtypes(include=\"number\").corr().round(2)\nplt.figure(figsize=(10, 8))\nsns.heatmap(corr, annot=True, cmap=\"coolwarm\", center=0)\nplt.title(\"Correlation Matrix\")\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/corr-matrix-output-1.png){#corr-matrix}\n:::\n:::\n\n\n:::\n\n8. Explore the relationships between rainfall, sunshine, and afternoon humidity across the cities. What patterns stand out?\n\n::: {.callout-note title=\"Solution\" collapse=\"true\"}\n\n::: {#cell-big-cities-pairplot .cell execution_count=36}\n``` {.python .cell-code}\nsns.pairplot(big_cities, vars=[\"Rainfall\", \"Sunshine\", \"Humidity3pm\"], hue=\"Location\")\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/big-cities-pairplot-output-1.png){#big-cities-pairplot}\n:::\n:::\n\n\n:::\n\n9. How has the maximum temperature in Brisbane changed over time? Create a time series visualisation.\n\n::: {.callout-note title=\"Solution\" collapse=\"true\"}\n\n::: {#cell-max-temp-over-time .cell execution_count=37}\n``` {.python .cell-code}\nbrisbane = big_cities.loc[big_cities[\"Location\"] == \"Brisbane\"]\nbrisbane['Date'] = pd.to_datetime(brisbane['Date'])\nbrisbane_daily = brisbane.groupby(\"Date\")[\"MaxTemp\"].mean().reset_index()\n\nplt.figure(figsize=(12, 4))\nsns.lineplot(data=brisbane_daily, x=\"Date\", y=\"MaxTemp\")\nplt.title(\"Daily Max Temp in Brisbane\")\n\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/max-temp-over-time-output-1.png){#max-temp-over-time}\n:::\n:::\n\n\n:::\n\n10. What does the distribution of daily rainfall amounts look like? Is it skewed or symmetric?\n\n::: {.callout-note title=\"Solution\" collapse=\"true\"}\n\n::: {#cell-rainfall-dist .cell execution_count=38}\n``` {.python .cell-code}\nsns.kdeplot(data=big_cities, x=\"Rainfall\", fill=True)\nplt.title(\"Rainfall Distribution\")\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/rainfall-dist-output-1.png){#rainfall-dist}\n:::\n:::\n\n\n:::\n\n11. How does the average morning wind speed compare across the five cities?\n\n::: {.callout-note title=\"Solution\" collapse=\"true\"}\n\n::: {#cell-wind-speed-by-city .cell execution_count=39}\n``` {.python .cell-code}\nsns.barplot(data=big_cities, x=\"Location\", y=\"WindSpeed9am\", ci=None)\nplt.title(\"Average Morning Wind Speed by City\")\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/wind-speed-by-city-output-1.png){#wind-speed-by-city}\n:::\n:::\n\n\n:::\n\n12. In Perth, is there any visible relationship between the amount of sunshine and rainfall?\n\n::: {.callout-note title=\"Solution\" collapse=\"true\"}\n\n::: {#cell-perth-sunshine-rainfall .cell execution_count=40}\n``` {.python .cell-code}\nperth = big_cities.loc[big_cities[\"Location\"] == \"Perth\"]\nsns.scatterplot(data=perth, x=\"Sunshine\", y=\"Rainfall\")\nplt.title(\"Sunshine vs Rainfall in Perth\")\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/perth-sunshine-rainfall-output-1.png){#perth-sunshine-rainfall}\n:::\n:::\n\n\n:::\n\n",
    "supporting": [
      "index_files\\figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}