{
  "hash": "d373d8da3eb99eead1d05d4d7669c05a",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"An Introduction to Data Types\"\nformat:\n  html: default\n  ipynb: default\n---\n\nThis session is the first in a series of programming fundamentals. We recognise that this content might be a bit more dry and abstract, but it is important background to know when you start to actually use Python in your day to day work.\n\nIf you've used Excel and changed the data format for a cell, you've already come across data types! It is important to understand how Python stores values in variables and the pitfalls, gotchas and errors you may come across when working with data. The slide deck below gives a (*little*) bit of history before giving an overview of how data types work in Python. On the last slides are some links to useful resources on the web, which you may want to make note of for the future. Below the slides is a live notebook that demonstrates this, with some exercises at the end to check your understanding.\n\n# Slides\n\nUse the left ⬅️ and right ➡️ arrow keys to navigate through the slides below. To view in a separate tab/window, [follow this link](slides.html){target=\"_blank\"}.\n\n<iframe src=\"slides.html\" height=\"500\" width=\"100%\"></iframe>\n\n# Assigning types to variables\n\n## Automatically\n\nPython automatically assigns a type to a variable based on the value we put into it when we use the `=` assignment operator.\n\n::: {#124710cd .cell execution_count=1}\n``` {.python .cell-code}\nour_integer = 1\nour_float = 2.2\nour_integer_turned_into_a_float = float(our_integer)\nour_string=\"Hello SCW!\"\n```\n:::\n\n\n## Manually\n\nIf we need to, we can use a *constructor function* named after the data type, like `int()` or `str()` to force a variable to be the specific type we need it to be.\n\n::: {#c0401892 .cell execution_count=2}\n``` {.python .cell-code}\na = str(\"123\") # a will contain the string 123 rather than the numeric value\nb = float(2) # b will contain the decimal value 2.0\nc = int(1.9) # just throws away the .9; not rounded!\n```\n:::\n\n\n## Finding out what type a variable is\n\n::: {#4dcd4f50 .cell execution_count=3}\n``` {.python .cell-code}\nprint (type(a)) # output: <class 'str'>\nprint (type(b)) # output: <class 'float'>\nprint (type(c)) # output: <class 'int'>\n```\n:::\n\n\n# Data types\n\n## Booleans\n\nBools are often an intermediate - they are an output of evaluations like `1 == 2`. Booleans may sound very basic, but they are crucial in understanding control flow, which we'll be covering in a future session!\n\n::: {#fc8419ea .cell execution_count=4}\n``` {.python .cell-code}\nz = True\t\t\t# you'll rarely ever assign a boolean directly like this, but do note they are\n\t\t\t\t\t# case sensitive; z = true wouldn't have worked here.\nprint(type(z)) \t\t# output: <class 'bool'>\nprint (10>9)\t\t# output: True\nprint (1 == 2)\t\t# output: False\n \nprint(bool(123))\t# output: True\nprint(bool(\"abc\"))\t# output: True\nprint(bool(None))\t# output: False\nprint(bool(0))\t\t# output: False\n```\n:::\n\n\n## Numeric types\n\nPython supports different kinds of numbers, including integers (`int`), floating point numbers (`float`). You can do basic arithmetic (+, -, *, /), exponentiation (**), and use built-in functions like `round()`, `abs()`, and `pow()`.\n\n::: {#505f2b20 .cell execution_count=5}\n``` {.python .cell-code}\na = 10  \t\t\t# int\nb = 3   \t\t\t# int\nc = 2.5 \t\t\t# float\nd = -2  \t\t\t# int\n\nprint(a+b) \t\t\t# output: 13, an int\nprint(a+c) \t\t\t# output: 12.5, a float\nprint(a ** (1/2))   # taking the square root of an int returns a float\n \nprint(float(a)) \t# output: 10.0\nprint(int(2.88)) \t# output: 2; just throws away the decimal part\n \nprint(round(2.88)) \t# output: 3\nprint(round(2.88,1))# output: 2.9\n```\n:::\n\n\n## Strings\n\nStrings are sequences of characters enclosed in quotes. They support indexing, slicing, and a range of methods like `.lower()`, `.replace()`, `.split()`, and .`join()`.\n\n::: {#d89b3bcd .cell execution_count=6}\n``` {.python .cell-code}\nstr_a = \"Hello\" \t\t\t # string\nstr_b = \"SCW!\"  \t\t\t # string\n\nstr_ab = str_a + \" \" + str_b # python repurposes the \"+\" to mean string concatenation as well as addition\nprint(str_ab)                # output: Hello SCW!\n \nprint(str_ab.find(\"SCW\"))\t # output:6 (the location in the string of the substring \"SCW\". Starts from 0!)\n \nstr_repeated = str_ab * 3 \nprint(str_repeated)          # output: Hello SCW!Hello SCW!Hello SCW!\n \nprint(len(str_a))  \t\t\t # output: 5\nprint(str_a[0])\t\t\t\t # output: H\nprint(str_a[0:3])\t\t\t # output: Hel (give me 3 characters starting at 0)\nprint(str_a[3:])\t\t\t # output: lo (give me everything starting at 3)\nprint(str_a[:5])\t\t\t # output: Hello (give me the first 5 characters)\n```\n:::\n\n\n## Lists\n\nLists are ordered, mutable (changeable) collections. They can hold any type of data and support operations like appending (`.append()`), removing (`.remove()`), and slicing (`our_list[1:4]`).\n\n::: {#74d7fc52 .cell execution_count=7}\n``` {.python .cell-code}\nfruits = [\"banana\", \"lychee\", \"raspberry\", \"apple\"]\nprint(fruits[0]) \t\t  # output: banana (string)\nprint(fruits[0:2])\t\t  # output: ['banana','lychee'] (list!)\nprint(fruits[-1])\t\t  # output: apple (string)\n \nfruits.append(\"orange\") \nprint(fruits) \t\t\t  # output: ['banana', 'lychee', 'raspberry', 'apple', 'orange']\n \nprint(\"orange\" in fruits) # output: True\nprint(\"tomato\" in fruits) # output: False\n \nfruits.sort() \nprint(fruits)\t\t\t  # output: ['apple', 'banana', 'lychee', 'orange', 'raspberry']\n```\n:::\n\n\nLists can contain any combination of other data types.\n\n::: {#8e16aaf5 .cell execution_count=8}\n``` {.python .cell-code}\nmixed_list = [\"blue\", \"green\", False, 2, 2.55]\nfor item in mixed_list: # we're using a loop here; don't worry if you don't recognise this syntax\n\tprint(type(item)) \t# output:<class 'str'> <class 'str'> <class 'bool'> <class 'int'> <class 'float'>\n```\n:::\n\n\n## Dicts\n\nDictionaries store key-value pairs and are optimized for lookups. Keys must be unique and are immutable, but values are mutable. You can add, update, or delete items using `dict[key] = value`, `dict.get(key)`, or `del dict[key]`.\n\n::: {#e0de38a4 .cell execution_count=9}\n``` {.python .cell-code}\nSCW_basic_info={\n\t\"org_code\"\t\t: \"0DF\",\n\t\"short_name\"\t: \"SCW CSU\",\n\t\"long_name\"\t\t: \"NHS South, Central and West Commissioning Support Unit\",\n\t\"year_opened\"\t: 2014,\n\t\"active\"\t\t: True,\n\t\"postcode\"\t\t: \"SO50 5PB\"\n}\n\nprint(type(SCW_basic_info[\"active\"]))\t\t# output: <class 'bool'>\nprint(type(SCW_basic_info[\"year_opened\"])) \t# output: <class 'int'>\n \nprint(SCW_basic_info[\"org_code\"])\t\t\t# output: \"0DF\"\nprint(len(SCW_basic_info))\t\t\t\t\t# output: 6\n \nSCW_basic_info[\"number_of_staff\"] = 1000\t# we can easily add a new key and value at the same time\n \nprint(len(SCW_basic_info))\t\t\t\t\t# output: 7\n \nSCW_basic_info[\"number_of_staff\"] += 1 \t\t# we hired a new member of staff\nprint(SCW_basic_info[\"number_of_staff\"])\t# output: 1001\n```\n:::\n\n\n# Manipulating data types\n\nWe can use our constructor functions (`str()`, `int()`, etc) to convert between types in a generally intuitive way - think `CAST()` from SQL but a little less clunky.\n\n::: {#bcd99d7e .cell execution_count=10}\n``` {.python .cell-code}\nstr_number = \"123\"\t        # creating a variable that has a number stored as a string\nprint(type(str_number))     # output:<class 'str'>\n\nstr_number=int(str_number)  # using the int() constructor function\nprint(type(str_number))     # output:<class 'int'>\n\na = 321                     # we didn't use a decimal point, so python assumes we want an int\nprint(type(a)) \t\t\t    # output:<class 'int'>\na = float(a)                # turning it into a float and overwriting itself this time\nprint(type(a)) \t\t\t    # output:<class 'float'>\n```\n:::\n\n\nIf we try to do something silly, we get an error.\n\n::: {#e0598dc5 .cell execution_count=11}\n``` {.python .cell-code}\nb = int(\"kiwi\")\t\t        # output: ValueError: invalid literal for int() with base 10: 'kiwi'\n```\n:::\n\n\n# Exercises\n\n1. Create a new variable with the name one_two_three, and assign it the value \"123\" as a string.\n\n::: {.callout-note title=\"Solution\" collapse=\"true\"}\n\n::: {#447107b5 .cell execution_count=12}\n``` {.python .cell-code}\none_two_three = \"123\" \n```\n:::\n\n\nUsing the double quotes is enough to force it to be a string, but you also could have done `one_two_three=str(123)`.\n:::\n\n2. Prove that it is indeed a string, before converting it to an integer, putting the result in a new variable and keeping the old one the same.\n\n::: {.callout-note title=\"Solution\" collapse=\"true\"}\n\n::: {#a4b39aa2 .cell execution_count=13}\n``` {.python .cell-code}\nprint(type(one_two_three))\none_two_three_number = int(one_two_three)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<class 'str'>\n```\n:::\n:::\n\n\n:::\n\n2. If you tried to add the string and int together (using the + operator) what would happen?\n\n::: {.callout-note title=\"Solution\" collapse=\"true\"}\nYou'd get an error - which exact error depends on whether you tried to add the string to the int, or the other way around. Python doesn't let you do this.\n:::\n\n3. Create a list that contains the names of your three favourite films.\n\n::: {.callout-note title=\"Solution\" collapse=\"true\"}\n\n::: {#ff5b9096 .cell execution_count=14}\n``` {.python .cell-code}\ntop_three = [\"The Sound of Music\", \"Back to the Future\", \"Finding Nemo\"]\n```\n:::\n\n\nOf course, any set of films would have been fine :)\n:::\n\n4. Print the second film in your list.\n\n::: {.callout-note title=\"Solution\" collapse=\"true\"}\n\n::: {#c9e3119b .cell execution_count=15}\n``` {.python .cell-code}\nprint( top_three[1] )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nBack to the Future\n```\n:::\n:::\n\n\nRemember that array indices start at 0, so number 1 is the second element.\n:::\n\n5. We only have time to watch two films. Print the first two items in your list.\n\n::: {.callout-note title=\"Solution\" collapse=\"true\"}\n\n::: {#db7564cd .cell execution_count=16}\n``` {.python .cell-code}\nprint( top_three[0:2])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['The Sound of Music', 'Back to the Future']\n```\n:::\n:::\n\n\nThis syntax is (in my opinion) slightly confusing - it doesn't mean \"from 0 to 2\", it means \"start at 0 and give me two elements from the list\".\n\nAlternatively:\n\n::: {#4aba7b4d .cell execution_count=17}\n``` {.python .cell-code}\nprint( top_three[:2])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['The Sound of Music', 'Back to the Future']\n```\n:::\n:::\n\n\nDoes the same thing - omitting the `0` results in starting from the beginning by default\n\n:::\n\n\n6. Sort your list alphabetically, and then print it out to make sure it's worked. You may need to do a quick web search along the lines of \"python sort list\".\n\n::: {.callout-note title=\"Solution\" collapse=\"true\"}\n\n::: {#8ae8b745 .cell execution_count=18}\n``` {.python .cell-code}\ntop_three.sort()\nprint( top_three )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['Back to the Future', 'Finding Nemo', 'The Sound of Music']\n```\n:::\n:::\n\n\nAlternatively, you could have used `sorted()`, like this:\n\n::: {#3dbab318 .cell execution_count=19}\n``` {.python .cell-code}\ntop_three_sorted = sorted(top_three)\nprint( top_three_sorted )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['Back to the Future', 'Finding Nemo', 'The Sound of Music']\n```\n:::\n:::\n\n\n:::\n\n7. What is the result of doing `3 + 1.5` and what type is this result?\n\n::: {.callout-note title=\"Solution\" collapse=\"true\"}\n\nAdding an `int` to a `float` in Python results in a `float`. The result of this calculation is `4.5`.\n\n::: {#9d00390b .cell execution_count=20}\n``` {.python .cell-code}\nprint (3 + 1.5)\nprint(type(3 + 1.5)) # <class 'float'>\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n4.5\n<class 'float'>\n```\n:::\n:::\n\n\n:::\n\n8. What's the problem with the following code, and how would you correct it?\n\n::: {#47c87814 .cell execution_count=21}\n``` {.python .cell-code}\na = 1 + 2/3 # 1.66666...\nb = int(a)  # we only want whole numbers!\n```\n:::\n\n\n::: {.callout-note title=\"Solution\" collapse=\"true\"}\n\nThe problem is that changing a `float` into an `int` doesn't actually round the number, it just throws away the bit after the decimal point. Unless this is what we want, we should do this instead:\n\n::: {#c0392319 .cell execution_count=22}\n``` {.python .cell-code}\na = 1 + 2/3   # 1.66666...\nb = round(a)  # round to the nearest whole number\n```\n:::\n\n\n:::\n\n9. Create two strings, `first_name` and `last_name` and assign them to your first and last name, and then create a new string called `full_name` with your first and last name with a space in between. Print it to make sure it's worked.\n\n::: {.callout-note title=\"Solution\" collapse=\"true\"}\n\n::: {#4b83806e .cell execution_count=23}\n``` {.python .cell-code}\nfirst_name = \"Jane\"\nlast_name = \"Bloggs\"\nfull_name = first_name + \" \" + last_name\nprint(full_name)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nJane Bloggs\n```\n:::\n:::\n\n\n:::\n\n10. We have a `dict` that we created as follows:\n\n::: {#b20c66ac .cell execution_count=24}\n``` {.python .cell-code}\nperson = {\"first_name\": \"Jane\", \"last_name\": \"Bloggs\", \"year_of_birth\": 1967, \"post_code\": \"SO50 5PB\", \"person_number\": 122333}\n```\n:::\n\n\nPrint out Jane Bloggs' age, assuming she's already had her birthday this year.\n\n::: {.callout-note title=\"Solution\" collapse=\"true\"}\n\n::: {#1fcf6f96 .cell execution_count=25}\n``` {.python .cell-code}\nperson = {\"first_name\": \"Jane\", \"last_name\": \"Bloggs\", \"year_of_birth\": 1967, \"post_code\": \"SO50 5PB\", \"person_number\": 122333}\n\nage = 2025-person[\"year_of_birth\"]\nprint(age)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n58\n```\n:::\n:::\n\n\n:::\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}