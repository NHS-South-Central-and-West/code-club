{
  "hash": "abfd72c160083110b71e104e67af138d",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"An Introduction to Data Types\"\nformat:\n  html: default\n  ipynb: default\n---\n\nIntro paragraph\n\n# Slides\n\nUse the left ⬅️ and right ➡️ arrow keys to navigate through the slides below. To view in a separate tab/window, [follow this link](slides.html){target=\"_blank\"}.\n\n<iframe src=\"slides.html\" height=\"500\" width=\"100%\"></iframe>\n\n# Assigning types to variables\n\n## Automatically\n\nPython automatically assigns a type to a variable based on the value we put into it when we use the `=` assignment operator.\n\n::: {#e26335fd .cell execution_count=1}\n``` {.python .cell-code}\nour_integer = 1\nour_float = 2.2\nour_integer_turned_into_a_float = float(our_integer)\nour_string=\"Hello SCW!\"\n```\n:::\n\n\n## Manually\n\nIf we need to, we can use a *constructor function* named after the data type, like `int()` or `str()` to force a variable to be the specific type we need it to be.\n\n::: {#8656f5c1 .cell execution_count=2}\n``` {.python .cell-code}\na = str(\"123\") # a will contain the string 123 rather than the numeric value\nb = float(2) # b will contain the decimal value 2.0\nc = int(1.9) # just throws away the .9; not rounded!\n```\n:::\n\n\n## Finding out what type a variable is\n\n::: {#c8595c35 .cell execution_count=3}\n``` {.python .cell-code}\nprint (type(a))\nprint (type(b))\nprint (type(c))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<class 'str'>\n<class 'float'>\n<class 'int'>\n```\n:::\n:::\n\n\n# Data types\n\n## Booleans\n\nBools are often an intermediate - they are an output of evaluations like `1 == 2`. Booleans may sound very basic, but they are crucial in understanding control flow, which we'll be covering in a future session!\n\n::: {#9b671375 .cell execution_count=4}\n``` {.python .cell-code}\nz = True\t\t\t# you'll rarely ever assign a boolean directly like this, but do note they are\n\t\t\t\t\t# case sensitive; z = true wouldn't have worked here.\nprint(type(z)) \t\t# output: <class 'bool'>\nprint (10>9)\t\t# output: True\nprint (1 == 2)\t\t# output: False\n \nprint(bool(123))\t# output: True\nprint(bool(\"abc\"))\t# output: True\nprint(bool(None))\t# output: False\nprint(bool(0))\t\t# output: False\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<class 'bool'>\nTrue\nFalse\nTrue\nTrue\nFalse\nFalse\n```\n:::\n:::\n\n\n## Numeric types\n\nPython supports different kinds of numbers, including integers (int), floating point numbers (float). You can do basic arithmetic (+, -, *, /), exponentiation (**), and use built-in functions like round(), abs(), and pow().\n\n::: {#aead40a0 .cell execution_count=5}\n``` {.python .cell-code}\na = 10  \t\t\t# int\nb = 3   \t\t\t# int\nc = 2.5 \t\t\t# float\nd = -2  \t\t\t# int\n\nprint(a+b) \t\t\t# output: 13, an int\nprint(a+c) \t\t\t# output: 12.5, a float\nprint(a ** (1/2))   # taking the square root of an int returns a float\n \nprint(float(a)) \t# output: 10.0\nprint(int(2.88)) \t# output: 2; just throws away the decimal part\n \nprint(round(2.88)) \t# output: 3\nprint(round(2.88,1))# output: 2.9\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n13\n12.5\n3.1622776601683795\n10.0\n2\n3\n2.9\n```\n:::\n:::\n\n\n## Strings\n\nStrings are sequences of characters enclosed in quotes. They support indexing, slicing, and a wide range of methods like .lower(), .replace(), .split(), and .join().\n\n::: {#b800cc99 .cell execution_count=6}\n``` {.python .cell-code}\nstr_a = \"Hello\" \t\t\t # string\nstr_b = \"SCW!\"  \t\t\t # string\n\nstr_ab = str_a + \" \" + str_b # python repurposes the \"+\" to mean string concatenation as well as addition\nprint(str_ab)                # output: Hello SCW!\n \nprint(str_ab.find(\"SCW\"))\t # output:6 (the location in the string of the substring \"SCW\". Starts from 0!)\n \nstr_repeated = str_ab * 3 \nprint(str_repeated)          # output: Hello SCW!Hello SCW!Hello SCW!\n \nprint(len(str_a))  \t\t\t # output: 5\nprint(str_a[0])\t\t\t\t # output: H\nprint(str_a[0:3])\t\t\t # output: Hel (give me 3 characters starting at 0)\nprint(str_a[3:])\t\t\t # output: lo (give me everything starting at 3)\nprint(str_a[:5])\t\t\t # output: Hello (give me the first 5 characters)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHello SCW!\n6\nHello SCW!Hello SCW!Hello SCW!\n5\nH\nHel\nlo\nHello\n```\n:::\n:::\n\n\n## Lists\n\nLists are ordered, mutable (changeable) collections. They can hold any type of data and support operations like appending (`.append()`), removing (`.remove()`), and slicing (`our_list[1:4]`).\n\n::: {#17d21f9d .cell execution_count=7}\n``` {.python .cell-code}\nfruits = [\"banana\", \"lychee\", \"raspberry\", \"apple\"]\nprint(fruits[0]) \t\t#output: banana (string)\nprint(fruits[0:2])\t\t#output: ['banana','lychee'] (list!)\nprint(fruits[-1])\t\t#output: apple (string)\n\nfruits.append(\"orange\")\nprint(fruits) \t\t\t#output: ['banana', 'lychee', 'raspberry', 'apple', 'orange']\n\nprint(\"orange\" in fruits) #output: True\nprint(\"tomato\" in fruits) #output: False\n\nfruits.sort()\nprint(fruits)\t\t\t#output: ['apple', 'banana', 'lychee', 'orange', 'raspberry']\n\nmixed_list = [\"blue\", \"green\", False, 2, 2.55] #each item in a list can be a different data type!\nfor item in mixed_list:\n\tprint(type(item)) \t#output:<class 'str'> <class 'str'> <class 'bool'> <class 'int'> <class 'float'>\n\nstr_number = \"123\"\nprint(type(str_number)) #output:<class 'str'>\nstr_number=int(str_number)\nprint(type(str_number)) #output:<class 'int'>\n\na = 321\nprint(type(a)) \t\t\t#output:<class 'int'>\na = float(a)\nprint(type(a)) \t\t\t#output:<class 'float'>\n\n#b = int(\"kiwi\")\t\t#output: ValueError: invalid literal for int() with base 10: 'kiwi'\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nbanana\n['banana', 'lychee']\napple\n['banana', 'lychee', 'raspberry', 'apple', 'orange']\nTrue\nFalse\n['apple', 'banana', 'lychee', 'orange', 'raspberry']\n<class 'str'>\n<class 'str'>\n<class 'bool'>\n<class 'int'>\n<class 'float'>\n<class 'str'>\n<class 'int'>\n<class 'int'>\n<class 'float'>\n```\n:::\n:::\n\n\n## Dicts\n\nDictionaries store key-value pairs and are optimized for lookups. Keys must be unique and are immutable, but values are mutable. You can add, update, or delete items using dict[key] = value, dict.get(key), or del dict[key].\n\n::: {#83c05730 .cell execution_count=8}\n``` {.python .cell-code}\nSCW_basic_info={\n\t\"org_code\"\t\t: \"0DF\",\n\t\"short_name\"\t: \"SCW CSU\",\n\t\"long_name\"\t\t: \"NHS South, Central and West Commissioning Support Unit\",\n\t\"year_opened\"\t: 2014,\n\t\"active\"\t\t: True,\n\t\"postcode\"\t\t: \"SO50 5PB\"\n}\n\nprint(type(SCW_basic_info[\"active\"]))\t\t#output: <class 'bool'>\nprint(type(SCW_basic_info[\"year_opened\"])) \t#output: <class 'int'>\n\nprint(SCW_basic_info[\"org_code\"])\t\t\t#output: \"0DF\"\nprint(len(SCW_basic_info))\t\t\t\t\t#output: 6\n\nSCW_basic_info[\"number_of_staff\"] = 1000\t#we can easily add a new key and value at the same time\n\nprint(len(SCW_basic_info))\t\t\t\t\t#output: 7\n\nSCW_basic_info[\"number_of_staff\"] += 1 \t\t#we hired a new member of staff\nprint(SCW_basic_info[\"number_of_staff\"])\t#output: 1001\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<class 'bool'>\n<class 'int'>\n0DF\n6\n7\n1001\n```\n:::\n:::\n\n\n# Exercises\n\n---\njupyter:\n  kernelspec:\n    display_name: Python 3 (ipykernel)\n    language: python\n    name: python3\n    path: C:\\Users\\jonas.willemsen\\GitHub\\code-club\\.venv\\share\\jupyter\\kernels\\python3\n---\n",
    "supporting": [
      "index_files\\figure-ipynb"
    ],
    "filters": []
  }
}