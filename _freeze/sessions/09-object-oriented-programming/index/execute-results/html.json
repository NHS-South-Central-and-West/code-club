{
  "hash": "7fed8505fe10cce786af3684b501b04d",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"An Introduction to Object-Oriented Programming\"\nformat:\n  html: default\n  ipynb: default\n---\n\nThis session is the last in our series on fundamental programming concepts. It is an introduction to the programming paradigm that underpins Python, making it flexible and comparatively accessible to people starting out with coding.\n\nWhile the concepts discussed can feel a little abstract at times, they will make ever more sense the more practical experience you have with Python. This will help you understand how the packages you use function and will hopefully lead you one day to create some sophisticated programs yourself!\n\nIf you want to download the Jupyter notebook so that you can run the code yourself, modify it, and generally have a play, you can download it by clicking on the \"Jupyter\" link under \"Other Formats\" over on the right-hand side below the page contents.\n\n## Session Slides\n\nUse the left ⬅️ and right ➡️ arrow keys to navigate through the slides below. To view in a separate tab/window, [follow this link](slides.html){target=\"_blank\"}.\n\n<iframe src=\"slides.html\" height=\"500\" width=\"100%\"></iframe>\n\n## A closer look at some of the basics\n\nHere is a simple demonstration of how everything, down to individual integers, is treated as an object. When we run the dir() function on an integer and print the results, we can see all of the object attributes and methods associated with it.\n\n::: {#dir-demo .cell execution_count=1}\n``` {.python .cell-code}\nmy_int = 5\n\nprint(dir(my_int))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['__abs__', '__add__', '__and__', '__bool__', '__ceil__', '__class__', '__delattr__', '__dir__', '__divmod__', '__doc__', '__eq__', '__float__', '__floor__', '__floordiv__', '__format__', '__ge__', '__getattribute__', '__getnewargs__', '__getstate__', '__gt__', '__hash__', '__index__', '__init__', '__init_subclass__', '__int__', '__invert__', '__le__', '__lshift__', '__lt__', '__mod__', '__mul__', '__ne__', '__neg__', '__new__', '__or__', '__pos__', '__pow__', '__radd__', '__rand__', '__rdivmod__', '__reduce__', '__reduce_ex__', '__repr__', '__rfloordiv__', '__rlshift__', '__rmod__', '__rmul__', '__ror__', '__round__', '__rpow__', '__rrshift__', '__rshift__', '__rsub__', '__rtruediv__', '__rxor__', '__setattr__', '__sizeof__', '__str__', '__sub__', '__subclasshook__', '__truediv__', '__trunc__', '__xor__', 'as_integer_ratio', 'bit_count', 'bit_length', 'conjugate', 'denominator', 'from_bytes', 'imag', 'is_integer', 'numerator', 'real', 'to_bytes']\n```\n:::\n:::\n\n\nTo see which are attributes and which are methods, you can run the following code. We won't run it here, because it produces quite a long list!\n\n::: {#meth-attr-demo .cell execution_count=2}\n``` {.python .cell-code}\nfor name in dir(my_int):\n    item = getattr(my_int, name)\n    if callable(item):  # if an item is callable, i.e. you can \"do\" something with it, it is a method\n        print(f\"{name} -> method\")\n    else:\n        print(f\"{name} -> attribute\") # otherwise, it is an attribute\n```\n:::\n\n\nMethods and attributes that are surrounded by double underscores are ones that are used \"behind the scenes\" to help objects behave in a certain way (this exhibits the principle of Abstraction mentioned in the presentation). The ones without are the ones that you would call directly when working with the objects.\n\n### Using methods\n\nBy now, you are likely to have come across operations that can be used to transform your data by tacking them onto the end of your variable name. These are _methods_ belonging to that variable's object.\n\n::: {#list-demo .cell execution_count=3}\n``` {.python .cell-code}\n# Here we are calling the \"append\" method of the list class.\n\nicb_list = ['QRL','QNQ','QU9','QSL'] # a list object\n\nicb_list.append('QNX') # calling the method and passing a parameter\n\nprint(icb_list)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['QRL', 'QNQ', 'QU9', 'QSL', 'QNX']\n```\n:::\n:::\n\n\nIf we apply the function dir() to our variable `icb_list`, we can see that \"append\" is one of the methods belonging to the list class.\n\n::: {#dir-list-demo .cell execution_count=4}\n``` {.python .cell-code}\nprint(dir(icb_list))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['__add__', '__class__', '__class_getitem__', '__contains__', '__delattr__', '__delitem__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__getstate__', '__gt__', '__hash__', '__iadd__', '__imul__', '__init__', '__init_subclass__', '__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__reversed__', '__rmul__', '__setattr__', '__setitem__', '__sizeof__', '__str__', '__subclasshook__', 'append', 'clear', 'copy', 'count', 'extend', 'index', 'insert', 'pop', 'remove', 'reverse', 'sort']\n```\n:::\n:::\n\n\n::: {.callout-tip}\n## Remember\nFunctions precede the variable `function(my_variable)`, whereas methods are the ones that come after the variable `my_variable.method()`.\n:::\n\nFunctions are not tied to a particular object class (for example, `print()` can be applied to most things), while methods are bound up with particular object classes (for example, the method `pop` is associated with lists, but not with integers).\n\nThe brackets that come after methods will often contain parameters that determine _how_ the method is applied to the variable. This can be as simple as saying what we want to append to a list, as in the above example, or they can be as complex as the hyperparameters used to fine-tune a machine learning model.\n\n### Accessing attributes\n\nTo access an _attribute_, you simply write `my_variable.attribute`. Below is an example of accessing the \"numerator\" and \"denominator\" attributes of an integer. In Python, integers have these to enable consistency when working with rational numbers, i.e. fractions.\n\n::: {#attr-demo .cell execution_count=5}\n``` {.python .cell-code}\nprint(my_int.numerator)\nprint(my_int.denominator)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n5\n1\n```\n:::\n:::\n\n\n$\\frac{5}{1} = 5$\n\nWhen you start working with machine learning models in Python, you will often want to access attributes such as `coef_` (regression) and `feature_importances_` (decision tree algorithms). \n\nNow let's move onto how we create our own classes.\n\n## The Anatomy of a Class\n\nLet us first of all look at a simple class to see how it is structured as a whole. Then we will look at each element in turn.\n\n::: {#create-class-demo .cell execution_count=6}\n``` {.python .cell-code}\nclass HealthProfessional:\n\n  daily_capacity = 7.5\n\n  def __init__(self, assignment_number, division, department):\n    self.assignment_number = assignment_number                 \n    self.division = division              \n    self.department = department                              \n\n  def treat_patient(self,patient_name):\n    print(f'Health professional {self.assignment_number} treated patient {patient_name}')\n```\n:::\n\n\n### Definition\n\nThe line begins the definition of the class. It starts with the `class` keyword, followed by the class name and a colon. By convention, classes in Python begin with a capital letter.\n\n::: {#class-definition-demo .cell execution_count=7}\n``` {.python .cell-code}\nclass HealthProfessional:\n```\n:::\n\n\n### Class attribute\n\nThe next element is a _class attribute_, that is to say an attribute where the value will initially be the same for all objects created from that class. All of my health professionals have a default `daily_capacity` of 7.5 working hours per day. Class attributes sit just below the class name with one indent. Class attributes are **optional**.\n\n::: {#class-attr-demo .cell execution_count=8}\n``` {.python .cell-code}\nclass HealthProfessional:\n  \n  daily_capacity = 7.5\n```\n:::\n\n\n### Constructor method\n\nNext comes the _constructor_ method, which goes by the name of `__init__`. The double underscores (a so-called \"dunder\" method) indicate that it is a method that remains internal to the object i.e. it is not something that is accessed by the end user.\n\nThe constructor method defines what happens when an object instance is created (instantiated). It determines which attributes require values to be passed to the object at instantiation and can also trigger some methods to be execute automatically.\n\nIt is written much in the same way as defining a function, starting with the keyword `def`. The first argument of the function is _always_ `self` and is followed by arguments representing each of the object attributes.\n\nBelow that, each object attribute is bound to `self` with the `self.attribute` syntax and the `= attribute` syntax means that the corresponding value that gets passed to the object at instantiation will be assigned to that attribute.\n\n::: {#constructor-demo .cell execution_count=9}\n``` {.python .cell-code}\n  def __init__(self, assignment_number, division, department):\n    self.assignment_number = assignment_number                 \n    self.division = division              \n    self.department = department    \n```\n:::\n\n\n#### Some quick notes on `self`\n\n- `self` stores the instance of each object within the computer's memory.\n- whenever we define a class method, we include `self` because we want to run this method _in relation to this instance_ when we call it.\n- whenever we define an object attribute, we include `self` because we want to be able access the attribute value that _belongs to this instance_. \n\n### Class method\n\nNow, returning to the definition of a class, we come to the _class method_.\n\nIt is again defined just like a normal function, and this time we can give it whatever name we like. The first argument is _always_ `self`, which is followed by any other arguments relevant to the method. In our example, we want to pass a `patient_name` to the HealthProfessional object so that it knows which patient it is being asked to treat.\n\n::: {#method-demo .cell execution_count=10}\n``` {.python .cell-code}\n  def treat_patient(self,patient_name):\n    print(f'Health professional {self.assignment_number} treated patient {patient_name}')\n```\n:::\n\n\n### Our class in action\n\nNow we can have a look at our HealthProfessional class in action.\n\nFirst of all, we need to instantiate a HealthProfessional object. We need to assign it to a variable name so that we can easily refer to the object later on.\n\n::: {#instantiation-demo .cell execution_count=11}\n``` {.python .cell-code}\ndoctor_duggee = HealthProfessional(\n  assignment_number = 12345,          # writing out the argument names is optional\n  division = \"A\",\n  department= \"Surgery\"\n)\n```\n:::\n\n\nWe can use the `.treat_patient` method:\n\n::: {#method-use-demo .cell execution_count=12}\n``` {.python .cell-code}\ndoctor_duggee.treat_patient(\"Betty\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHealth professional 12345 treated patient Betty\n```\n:::\n:::\n\n\nWe can access the object's object attributes:\n\n::: {#attr-use-demo .cell execution_count=13}\n``` {.python .cell-code}\nprint(f'Health Professional {doctor_duggee.assignment_number} works in the {doctor_duggee.department} department')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHealth Professional 12345 works in the Surgery department\n```\n:::\n:::\n\n\nAnd we can access the class attribute:\n\n::: {#cell-access-attr-demo .cell execution_count=14}\n``` {.python .cell-code}\ndoctor_duggee.daily_capacity\n```\n\n::: {#access-attr-demo .cell-output .cell-output-display execution_count=9}\n```\n7.5\n```\n:::\n:::\n\n\nIt is also very easy to update an object's attribute values. Compare this with updating the values in a `dict`, which can be quite [fiddly](https://www.geeksforgeeks.org/python-replace-dictionary-value-from-other-dictionary/).\n\n::: {#update-attr-demo .cell execution_count=15}\n``` {.python .cell-code}\ndoctor_duggee.department = 'Medicine for Older Persons'\ndoctor_duggee.division = 'C'\n\nprint(f'Health Professional {doctor_duggee.assignment_number} works in the {doctor_duggee.department} department in Division {doctor_duggee.division}')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHealth Professional 12345 works in the Medicine for Older Persons department in Division C\n```\n:::\n:::\n\n\nClass attribute values can be updated at object level in the same way. This change won't affect new objects created from the class. Think of class attributes as holding a common _default_ value.\n\n::: {#update-class-attr-demo .cell execution_count=16}\n``` {.python .cell-code}\ndoctor_duggee.daily_capacity = 8\nprint(f'Duggee\\'s daily capacity: {doctor_duggee.daily_capacity} hours.')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDuggee's daily capacity: 8 hours.\n```\n:::\n:::\n\n\n## Inheritance\n\nOne of the main strengths of object-oriented programming is the ability to create _child_ classes from other classes (the original, _parent_ classes). This allows us to create classes that modify or extend the data (attributes) and behaviours (methods) of the parent class, without altering the parent class itself. Multiple child classes can be created which share the attributes and methods _consistently_, but extend or modify them in their own way.\n\nLet us have a look at how a child class gets created from the parent class. Again, we will start off with the child class written out in full so that you can see how it would look. Then we will go through it line by line.\n\nWe are going to create \"Doctor\" and \"Nurse\" child classes of the `HealthProfessional` parent class. They will inherit the attributes and methods of the `HealthProfessional` class, but extend them in their own way.\n\n::: {#create-child--demo .cell execution_count=17}\n``` {.python .cell-code}\nclass Doctor(HealthProfessional):\n    def __init__(self,assignment_number,division,department,seniority):\n        self.seniority = seniority\n        super().__init__(assignment_number,division,department)\n\n    def discharge_patient(self,patient_name):\n        print(f'Doctor {self.assignment_number} discharged patient {patient_name}')\n\n```\n:::\n\n\n### Child class definition\n\nFirst of all, when defining a child class, we start off with the keyword `class` followed by the name of the child class, followed by the name of the parent class in brackets, ending with a colon.\n\n::: {#child-definition-demo .cell execution_count=18}\n``` {.python .cell-code}\nclass Doctor(HealthProfessional):\n```\n:::\n\n\n### Child class constructor method and child attributes\n\nThen, with one indentation, we write the constructor method, just as we did with the parent class. Remember, we must always enter `self` as the first argument. Then we need to enter the names of the attributes that the child class will inherit from the parent, followed by any new object attributes. In the second line, the any new object attributes are bound to `self`.\n\n::: {#child-constructor-demo .cell execution_count=19}\n``` {.python .cell-code}\n    def __init__(self,assignment_number,division,department,seniority):\n        self.seniority = seniority\n```\n:::\n\n\n### The super(). function\n\nBelow any new attributes, we enter a line that draws down any methods and attributes from the parent class. `super()` is a function that calls the constructor function from the parent class.\n\n::: {#super-demo .cell execution_count=20}\n``` {.python .cell-code}\n        super().__init__(assignment_number,division,department)\n```\n:::\n\n\nNote that you do not need to refer to any methods or _class_ attributes here. They automatically get replicated by the super() method. The only elements that you need to explicitly mention are the _object_ attributes defined in the parent class.\n\n::: {.callout-tip}\n## Remember\n**Class** attributes are the ones that have \"default\" values that are common to all objects created from a class. In our `HealthProfessional` example, this was `daily_capacity`. They are written just under the class name and are not bound to `self`.\n**Object** attributes receive their values when an object is instantiated and are specific to that object. They are bound to `self`.\n:::\n\n### Child-specific methods\n\nLast in our example is the definition of any new methods that are specific to the _child_ class. `Doctor` objects will be able to treat patients with the inherited `.treat_patient()` method, but we are also going to give them the ability to discharge patients with the `.discharge_patient()` method.\n\nAs with the `.treat_patient()` method in the parent class, we use the `def` keyword, followed by the name of the method for the child class, `self` as the first argument, and the name of any variable that we want to pass to the method, in this case the name of the patient we want to discharge.\n\n::: {#child-method-demo .cell execution_count=21}\n``` {.python .cell-code}\n    def discharge_patient(self,patient_name):\n        print(f'Doctor {self.assignment_number} discharged patient {patient_name}')\n```\n:::\n\n\n### Our child class in action\n\nLet's create an object instance of the `Doctor` class and try out the methods and attributes.\n\n::: {#child-instantiation-demo .cell execution_count=22}\n``` {.python .cell-code}\ndoctor_peppa = Doctor(\n  999999,\n  \"B\",\n  \"Ophthalmology\",\n  \"Consultant\"\n)\n```\n:::\n\n\n::: {#child-attr-demo .cell execution_count=23}\n``` {.python .cell-code}\nprint(f'Assignment number: {doctor_peppa.assignment_number}')\nprint(f'Division: {doctor_peppa.division}')\nprint(f'Department: {doctor_peppa.department}')\nprint(f'Seniority: {doctor_peppa.seniority}')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nAssignment number: 999999\nDivision: B\nDepartment: Ophthalmology\nSeniority: Consultant\n```\n:::\n:::\n\n\nNote that we can still retrieve the `daily_capacity` attribute, which was defined in the parent class `HealthProfessional`\n\n::: {#cell-child-class-attr-demo .cell execution_count=24}\n``` {.python .cell-code}\ndoctor_peppa.daily_capacity\n```\n\n::: {#child-class-attr-demo .cell-output .cell-output-display execution_count=15}\n```\n7.5\n```\n:::\n:::\n\n\nHowever, we can prove that Doctor Peppa is a `Doctor` object and not a `HealthProfessional` object by using Python's type() function\n\n::: {#cell-type-demo .cell execution_count=25}\n``` {.python .cell-code}\ntype(doctor_peppa)\n```\n\n::: {#type-demo .cell-output .cell-output-display execution_count=16}\n```\n__main__.Doctor\n```\n:::\n:::\n\n\nWe can also test Doctor Peppa's methods:\n\n::: {#inherited-method-use-demo .cell execution_count=26}\n``` {.python .cell-code}\ndoctor_peppa.treat_patient(\"Suzy Sheep\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHealth professional 999999 treated patient Suzy Sheep\n```\n:::\n:::\n\n\n::: {.callout-tip}\n## Interesting...\nDid you notice how it said \"Health professional\"? This was actually unintentional, but it neatly demonstrates how the `.treat_patient()` method has been inherited from the parent class (because the text of the statement wasn't amended when the child class was created).\n:::\n\n::: {#child-method-use-demo .cell execution_count=27}\n``` {.python .cell-code}\ndoctor_peppa.discharge_patient(\"Suzy Sheep\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDoctor 999999 discharged patient Suzy Sheep\n```\n:::\n:::\n\n\nWhat happens if Doctor Duggee tries to discharge a patient? Try uncommenting the Python below and running the cell.\n\n::: {#unavailable-method-demo .cell execution_count=28}\n``` {.python .cell-code}\n# doctor_duggee.discharge_patient(\"Happy\")\n```\n:::\n\n\nWe get an error, because `doctor_duggee` is a `HealthProfessional` object, which does not contain the `.discharge_patient()` method.\n\nIf you want to turn `doctor_duggee` into a `Doctor` object, you need to instantiate him as such.\n\n::: {#cell-reinstantiate-demo .cell execution_count=29}\n``` {.python .cell-code}\ndoctor_duggee = Doctor(\n  assignment_number = 12345,\n  division = \"A\",\n  department= \"Surgery\",\n  seniority=\"Resident\"\n)\n\ntype(doctor_duggee)\n```\n\n::: {#reinstantiate-demo .cell-output .cell-output-display execution_count=20}\n```\n__main__.Doctor\n```\n:::\n:::\n\n\n### Defining a second child class\n\nLet's quickly define the `Nurse` child class of `HealthProfessional` to demonstrate how different child classes can share the same inherited characteristics, but still have their own.\n\nInstead of `seniority`, `Nurse` objects will have `band` and `role` attributes, and instead of `.discharge_patient()` the method `.take_readings()`.\n\n::: {#second-child-demo .cell execution_count=30}\n``` {.python .cell-code}\nclass Nurse(HealthProfessional):\n    def __init__(self,assignment_number,division,department,band,role):\n        self.band = band\n        self.role = role\n        super().__init__(assignment_number,division,department)\n\n  # Adding a new method to the child class\n    def take_readings(self,patient_name):\n        print(f'Nurse {self.assignment_number} took the vital signs readings of {patient_name}')\n```\n:::\n\n\n::: {#instantiate-second-child-demo .cell execution_count=31}\n``` {.python .cell-code}\nnurse_tag = Nurse(\n  assignment_number = 10101,\n  division = \"A\",\n  department = \"Cancer Care\",\n  band = \"5\",\n  role = \"Staff Nurse\"\n)\n\nprint(f'Assignment number:  {nurse_tag.assignment_number}')\nprint(f'Division: {nurse_tag.division}')\nprint(f'Department: {nurse_tag.department}')\nprint(f'AfC Band: {nurse_tag.band}')\nprint(f'Role: {nurse_tag.role}')\nprint(f'Daily Capacity: {nurse_tag.daily_capacity}')\n\nnurse_tag.take_readings(\"Roly\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nAssignment number:  10101\nDivision: A\nDepartment: Cancer Care\nAfC Band: 5\nRole: Staff Nurse\nDaily Capacity: 7.5\nNurse 10101 took the vital signs readings of Roly\n```\n:::\n:::\n\n\n### The isinstance() function\n\nThere is also a function that can check whether an object belongs to a specified class. (This is particularly useful for checking data types when a specific type needs to be enforced, given that every variable is treated as an object belonging to a particular class. This data type enforcement doesn't happen by default in Python since it is a dynamically-typed language. Leaving this up to Python could lead to a mismatch of data types, which could lead to errors further down the line).\n\n::: {#cell-isinstance-demo .cell execution_count=32}\n``` {.python .cell-code}\nisinstance(nurse_tag,Nurse)\n```\n\n::: {#isinstance-demo .cell-output .cell-output-display execution_count=23}\n```\nTrue\n```\n:::\n:::\n\n\n::: {#isinstance-check-demo .cell execution_count=33}\n``` {.python .cell-code}\n# Imagine we wanted to ensure that AfC bands always get stored as strings\n# for consistency since they can include alphanumeric values (e.g. \"8a\") as\n# well as purely numeric values (e.g. \"6\")\n\nmy_input = 7 # this will be interpreted as an integer\n\nif isinstance(my_input,str):\n  print('Valid input')\nelse:\n  print('Invalid input: this field only accepts text strings')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nInvalid input: this field only accepts text strings\n```\n:::\n:::\n\n\nThose are the fundamentals of how to create classes and objects. Let's have a look at something a _bit_ more advanced to give you an idea of something you might want to create for a team of analysts.\n\n## A practical example\n\nBelow is an example of how we might create an standard SCW chart template for different kinds of charts using a class. **The string and Boolean values in the constructor method are default values that can be overwritten by any values passed to the object at instantiation.**\n\n::: {#practical-example-demo .cell execution_count=34}\n``` {.python .cell-code}\nimport matplotlib.pyplot as plt\n\nclass SCWPlot:\n  def __init__(self, x_data, y_data, title=\"SCW Plot\", xlabel=\"X-axis\", ylabel=\"Y-axis\", grid=False):\n    self.x_data = x_data\n    self.y_data = y_data\n    self.title = title\n    self.xlabel = xlabel\n    self.ylabel = ylabel\n    self.grid = grid\n    # Colour palette based on SCW colours\n    self.palette = ['#1C355E','#005EB8','#00A9CE','#330072','#78BE20']\n\n  # This part is a method internal to the class. It is not accessed by users, but helps to standardise\n  # the methods relating to each type of chart. By convention, these internal methods begin with an underscore.\n  def _setup_plot(self):\n    plt.figure(figsize=(8, 5))\n    plt.title(self.title)\n    plt.xlabel(self.xlabel)\n    plt.ylabel(self.ylabel)\n    plt.grid(visible=True,which='major',axis='both')\n    plt.tight_layout()\n\n  # The two methods below are each for a different kind of chart that the user can plot. They both make use of\n  # the ._setup_plot() to determine certain shared, consistent characteristics.\n  def plot_line(self, linestyle='-', marker='o'):\n    self._setup_plot()            # use the common structure defined above\n    plt.plot(                     # plot a line chart with the data passed to the object\n        self.x_data, \n        self.y_data, \n        color=self.palette[0],    # use the first value in the palette list\n        linestyle=linestyle, \n        marker=marker\n    )\n    plt.show()                    # display the chart\n\n  def plot_bar(self):\n    self._setup_plot()            # use the common structure defined above\n    plt.bar(                      # plot a bar chart with data passed to the object\n      self.x_data, \n      self.y_data, \n      color=self.palette\n    ) \n    plt.show()                    # display the chart\n```\n:::\n\n\nThen we will create a very simple dataset to use for testing the use of our class.\n\n::: {#create-chart-data-demo .cell execution_count=35}\n``` {.python .cell-code}\nx = ['A', 'B', 'C', 'D', 'E']\ny = [5, 7, 3, 8, 6]\n```\n:::\n\n\nNow we can instantiate an `SCWPlot` object and call the two chart type methods to produce charts.\n\n::: {#cell-instantiate-chart-demo .cell execution_count=36}\n``` {.python .cell-code}\nplot = SCWPlot(x, y, title=\"SCW-Branded Plot\", xlabel=\"Category\", ylabel=\"Value\")\n\nplot.plot_line()\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/instantiate-chart-demo-output-1.png){#instantiate-chart-demo}\n:::\n:::\n\n\n::: {#cell-second-chart-demo .cell execution_count=37}\n``` {.python .cell-code}\nplot.plot_bar()\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/second-chart-demo-output-1.png){#second-chart-demo}\n:::\n:::\n\n\nAs you can see, it becomes easy for the user to switch between different kinds of plots while maintaining a standard colour scheme and chart size.\n\nIn reality, you would not have all of the implementation code (i.e. the code written to create the class) in your script or notebook. This would stored in a separate Python file and the class would be imported into the script. In a future session we will talk about this and creating our own packages.\n\n#### Simple maintenance and extensibility\n\nCreating standardised functions as methods of a class helps to simplify maintaining and extending functionality. In the example above, things like the colour palette and figure size are defined once and these get cascaded to the methods relating to individual chart types, so they only need to be edited once. Furthermore, it is easy for a colleague to add another chart type (e.g. horizontal bar) with four lines of code, without necessarily having to understand in detail how the rest of the class has been constructed. This example produces relatively simple charts, but there is the potential to create a class that consistently produces timeseries charts with a preferred x-axis layout (something that can be quite fiddly to perfect!).\n\nWhile this class can be extended by adding more chart type methods, can you think of a possible reason for creating a child class from it?\n\n\n## Exercises\n\n1. How do you check what class a variable is?\n\n::: {.callout-note title=\"Solution\" collapse=\"true\"}\n\n::: {#cell-class-type .cell execution_count=38}\n``` {.python .cell-code}\nmy_variable = 5\n\ntype(my_variable)\n```\n\n::: {#class-type .cell-output .cell-output-display execution_count=29}\n```\nint\n```\n:::\n:::\n\n\n:::\n\n2. How would you check whether the value of the variable in the previous solution is an integer?\n\n::: {.callout-note title=\"Solution\" collapse=\"true\"}\n\n::: {#cell-check-type .cell execution_count=39}\n``` {.python .cell-code}\nisinstance(my_variable,int)\n```\n\n::: {#check-type .cell-output .cell-output-display execution_count=30}\n```\nTrue\n```\n:::\n:::\n\n\n:::\n\n3. Which function can be used to display all of the methods and attributes belonging to an object?\n\n::: {.callout-note title=\"Solution\" collapse=\"true\"}\n\n::: {#cell-list-attr-meth .cell execution_count=40}\n``` {.python .cell-code}\ndir(my_variable)\n```\n\n::: {#list-attr-meth .cell-output .cell-output-display execution_count=31}\n```\n['__abs__',\n '__add__',\n '__and__',\n '__bool__',\n '__ceil__',\n '__class__',\n '__delattr__',\n '__dir__',\n '__divmod__',\n '__doc__',\n '__eq__',\n '__float__',\n '__floor__',\n '__floordiv__',\n '__format__',\n '__ge__',\n '__getattribute__',\n '__getnewargs__',\n '__getstate__',\n '__gt__',\n '__hash__',\n '__index__',\n '__init__',\n '__init_subclass__',\n '__int__',\n '__invert__',\n '__le__',\n '__lshift__',\n '__lt__',\n '__mod__',\n '__mul__',\n '__ne__',\n '__neg__',\n '__new__',\n '__or__',\n '__pos__',\n '__pow__',\n '__radd__',\n '__rand__',\n '__rdivmod__',\n '__reduce__',\n '__reduce_ex__',\n '__repr__',\n '__rfloordiv__',\n '__rlshift__',\n '__rmod__',\n '__rmul__',\n '__ror__',\n '__round__',\n '__rpow__',\n '__rrshift__',\n '__rshift__',\n '__rsub__',\n '__rtruediv__',\n '__rxor__',\n '__setattr__',\n '__sizeof__',\n '__str__',\n '__sub__',\n '__subclasshook__',\n '__truediv__',\n '__trunc__',\n '__xor__',\n 'as_integer_ratio',\n 'bit_count',\n 'bit_length',\n 'conjugate',\n 'denominator',\n 'from_bytes',\n 'imag',\n 'is_integer',\n 'numerator',\n 'real',\n 'to_bytes']\n```\n:::\n:::\n\n\n:::\n\n4. How do you access an object's attributes? What is the syntax?\n\n::: {.callout-note title=\"Solution\" collapse=\"true\"}\n\n`object.attribute`\n\n::: {#cell-access-attr .cell execution_count=41}\n``` {.python .cell-code}\nmy_variable.numerator\n```\n\n::: {#access-attr .cell-output .cell-output-display execution_count=32}\n```\n5\n```\n:::\n:::\n\n\n:::\n\n5. How do you call an object's methods? What is the syntax?\n\n::: {.callout-note title=\"Solution\" collapse=\"true\"}\n\n`object.method()`\n\n::: {#cell-access-meth .cell execution_count=42}\n``` {.python .cell-code}\nmy_variable.is_integer()\n```\n\n::: {#access-meth .cell-output .cell-output-display execution_count=33}\n```\nTrue\n```\n:::\n:::\n\n\n:::\n\n\n6. Create a class called \"Patient\" with the characteristics below. You may wish to refer back to previous sessions on core programming concepts for guidance.\n\n- A class attribute called \"bed_space\" and assign it the value 1\n- Object attributes for \"patient_number\" and \"diagnosis\", values for which will be assigned at instantiation, and \"cured\" which has the default value of `False` as well as \"admitted\" with the default value of `True`\n- A method called \"get_well\" which updates the \"cured\" attribute to `True` and prints a statement that returns the \"patient_number\" and the \"diagnosis\" that the patient has been cured of. (Hint: you will need to use an f-string with the attributes embedded in the statement).\n- A method called \"get_discharged\" which checks whether the patient has been cured and if this is `True`, prints a statement to say that the patient has been discharged and sets \"admitted\" to `False`. Othwerwise, it prints a statement to say that the patient is not ready to be discharged.\n\n::: {.callout-note title=\"Solution\" collapse=\"true\"}\n\n::: {#create-class .cell execution_count=43}\n``` {.python .cell-code}\nclass Patient:\n\n  bed_space = 1\n\n  def __init__(self,patient_number,diagnosis):\n    self.patient_number = patient_number\n    self.diagnosis = diagnosis\n    self.cured = False\n    self.admitted = True\n\n  def get_well(self):\n    self.cured = True\n    print(f'Patient {self.patient_number} has been cured of {self.diagnosis}')\n  \n  def get_discharged(self):\n    if self.cured == True:\n      print(f'Patient {self.patient_number} has been discharged')\n      self.admitted = False\n    else:\n      print(f'Patient {self.patient_number} is not ready to be discharged')\n```\n:::\n\n\n:::\n\n7. Instantiate a Patient object with a \"patient_number\" and \"diagnosis\". Try discharging the patient before they have been cured, then call the `get_well` method and try discharging the patient again.\n\n::: {.callout-note title=\"Solution\" collapse=\"true\"}\n\n::: {#test-class .cell execution_count=44}\n``` {.python .cell-code}\nmy_patient = Patient(patient_number='12345',diagnosis='acute tummy ache')\n\nmy_patient.get_discharged()\n\nmy_patient.get_well()\n\nmy_patient.get_discharged()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nPatient 12345 is not ready to be discharged\nPatient 12345 has been cured of acute tummy ache\nPatient 12345 has been discharged\n```\n:::\n:::\n\n\n:::\n\n8. With the Patient object you created, how would you access the \"admitted\" attribute to check whether they are still an inpatient?\n\n::: {.callout-note title=\"Solution\" collapse=\"true\"}\n\n::: {#cell-access-admit .cell execution_count=45}\n``` {.python .cell-code}\nmy_patient.admitted\n```\n\n::: {#access-admit .cell-output .cell-output-display execution_count=36}\n```\nFalse\n```\n:::\n:::\n\n\n:::\n\n9. Create a child class called \"SurgeryPatient\" that inherits the methods and attributes from `Patient`. Add an attribute called \"theatre\" to store the name of the operating theatre that gets assigned when the object is created and a method that checks whether the patient has been cured or not. When `False`, the method prints a message requesting that the patient be transferred to the `theatre`, when `True` the method prints a message to say that the patient can proceed to discharge.\n\n::: {.callout-note title=\"Solution\" collapse=\"true\"}\n\n::: {#create-child .cell execution_count=46}\n``` {.python .cell-code}\nclass SurgeryPatient(Patient):\n  def __init__(self, patient_number, diagnosis, theatre):\n    self.theatre = theatre\n    super().__init__(patient_number, diagnosis)\n\n  def theatre_call(self):\n    if self.cured == False:\n      print(f'Please transfer patient {self.patient_number} to theatre {self.theatre}')\n    else:\n      print(f'Patient {self.patient_number} is now ready for discharge')\n```\n:::\n\n\n:::\n\n10. Instantiate a `SurgeryPatient` object, test whether the attributes and methods have been inherited from the `Patient` class, and test the `.theatre_call()` method. Your solution doesn't have to match exactly. Just be sure that you are able to test each element of the class.\n\n::: {.callout-note title=\"Solution\" collapse=\"true\"}\n\n::: {#test-child .cell execution_count=47}\n``` {.python .cell-code}\nmy_surgery_patient = SurgeryPatient(patient_number=54321,diagnosis='a broken leg',theatre='11F')\n\nprint(f'This patient occupies {my_surgery_patient.bed_space} bed')\n\nmy_surgery_patient.get_discharged()\n\nmy_surgery_patient.theatre_call()\n\nmy_surgery_patient.get_well()\n\nmy_surgery_patient.theatre_call()\n\nmy_surgery_patient.get_discharged()\n\nprint(f'Is this patient still on our inpatient ward? {my_surgery_patient.admitted}')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nThis patient occupies 1 bed\nPatient 54321 is not ready to be discharged\nPlease transfer patient 54321 to theatre 11F\nPatient 54321 has been cured of a broken leg\nPatient 54321 is now ready for discharge\nPatient 54321 has been discharged\nIs this patient still on our inpatient ward? False\n```\n:::\n:::\n\n\n:::\n\n## Bonus challenge\n\n::: {.callout-note}\nWe haven't provided a suggested solution for this one, but do feel free to discuss potential answers in the Code Club channels.\n:::\n\nInstantiate a smallish number of Patient objects (no need to spend too much time on this, but you do need more than one!). Can you work out a way to total the amount of bed space occupied by your patients by summing together the `bed_space` class attribute values? Try using a loop.\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}